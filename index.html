<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Restaurant POS - Same WiFi Sync</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #f5f5f5;
      color: #333;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .nav {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .nav button {
      padding: 12px 24px;
      border: none;
      background: #007bff;
      color: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.2s;
    }

    .nav button:hover {
      background: #0056b3;
    }

    .nav button.active {
      background: #28a745;
    }

    .content {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      min-height: 500px;
    }

    .section {
      display: none;
    }

    .section.active {
      display: block;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .card {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      border: 2px solid #e9ecef;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .card:hover {
      border-color: #007bff;
      transform: translateY(-2px);
    }

    .card.occupied {
      background: #fff3cd;
      border-color: #ffc107;
    }

    .card h3 {
      font-size: 20px;
      margin-bottom: 8px;
    }

    .card p {
      color: #666;
      font-size: 14px;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
      overflow-y: auto;
    }

    .modal.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 12px;
      width: 90%;
      max-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
      margin: 20px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .form-group input, .form-group textarea, .form-group select {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 16px;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.2s;
    }

    .btn-primary {
      background: #007bff;
      color: white;
    }

    .btn-primary:hover {
      background: #0056b3;
    }

    .btn-success {
      background: #28a745;
      color: white;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .menu-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
      margin-bottom: 10px;
    }

    .menu-item-info h4 {
      margin-bottom: 5px;
    }

    .menu-item-price {
      font-weight: bold;
      color: #28a745;
    }

    .order-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .order-summary {
      margin-top: 20px;
      padding: 20px;
      background: #e9ecef;
      border-radius: 8px;
    }

    .order-card {
      background: white;
      padding: 20px;
      border-radius: 8px;
      border-left: 4px solid #007bff;
      margin-bottom: 15px;
    }

    .order-card.processing {
      border-left-color: #ffc107;
    }

    .order-card.ready {
      border-left-color: #28a745;
    }

    .order-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #e9ecef;
    }

    .status-badge {
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
    }

    .status-badge.new {
      background: #007bff;
      color: white;
    }

    .status-badge.processing {
      background: #ffc107;
      color: #333;
    }

    .status-badge.ready {
      background: #28a745;
      color: white;
    }

    .device-card {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #e9ecef;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .device-card.active {
      border-color: #28a745;
      background: #e8f5e8;
    }

    .device-info {
      display: flex;
      flex-direction: column;
    }

    .device-name {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .device-ip {
      font-size: 12px;
      color: #666;
    }

    .device-status {
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 12px;
      background: #6c757d;
      color: white;
    }

    .device-status.connected {
      background: #28a745;
    }

    .device-status.syncing {
      background: #ffc107;
      color: #333;
    }

    .sync-indicator {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 10px 20px;
      background: #28a745;
      color: white;
      border-radius: 20px;
      font-size: 14px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 1000;
    }

    .sync-indicator.syncing {
      background: #ffc107;
    }

    .sync-indicator.error {
      background: #dc3545;
    }

    .sync-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: white;
    }

    .sync-dot.pulsing {
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }

    .network-status {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 8px 16px;
      background: #6c757d;
      color: white;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
    }

    .network-status.online {
      background: #28a745;
    }

    .network-status.offline {
      background: #dc3545;
    }

    .network-status.local {
      background: #17a2b8;
    }

    .chat-message {
      padding: 10px;
      margin: 5px 0;
      border-radius: 8px;
      background: #f8f9fa;
      border-left: 4px solid #007bff;
    }

    .chat-message.remote {
      background: #e9ecef;
      border-left-color: #28a745;
    }

    .chat-input {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .chat-input input {
      flex: 1;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
    }

    @media (max-width: 768px) {
      .grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }
      
      .modal-content {
        padding: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="network-status" id="networkStatus">Checking Network...</div>
  
  <div class="container">
    <div class="header">
      <h1 style="margin-bottom: 20px;">Restaurant POS - Local WiFi Sync</h1>
      <div class="nav">
        <button onclick="showSection('tables')" class="active" id="nav-tables">Tables</button>
        <button onclick="showSection('menu')" id="nav-menu">Menu</button>
        <button onclick="showSection('kitchen')" id="nav-kitchen">Kitchen</button>
        <button onclick="showSection('network')" id="nav-network">Network Sync</button>
        <button onclick="showSection('chat')" id="nav-chat">Staff Chat</button>
      </div>
    </div>

    <div class="content">
      <!-- Tables Section -->
      <div id="tables" class="section active">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <h2>Tables</h2>
          <button class="btn btn-primary" onclick="showAddTableModal()">Add Table</button>
        </div>
        <div id="tablesGrid" class="grid"></div>
      </div>

      <!-- Menu Section -->
      <div id="menu" class="section">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <h2>Menu Items</h2>
          <button class="btn btn-primary" onclick="showAddMenuModal()">Add Item</button>
        </div>
        <div id="menuList"></div>
      </div>

      <!-- Kitchen Section -->
      <div id="kitchen" class="section">
        <h2 style="margin-bottom: 20px;">Kitchen Display</h2>
        <div id="kitchenOrders"></div>
      </div>

      <!-- Network Sync Section -->
      <div id="network" class="section">
        <h2 style="margin-bottom: 20px;">Local Network Sync</h2>
        
        <div class="form-group">
          <label>Device Name</label>
          <div style="display: flex; gap: 10px;">
            <input type="text" id="deviceName" value="POS Terminal 1" style="flex: 1;">
            <button class="btn btn-primary" onclick="updateDeviceName()">Update</button>
          </div>
        </div>

        <div class="form-group">
          <label>Sync Mode</label>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button class="btn btn-primary" onclick="startWebSocketServer()" id="wsServerBtn">Start WebSocket Server</button>
            <button class="btn btn-secondary" onclick="connectToWebSocket()" id="wsClientBtn">Connect to Server</button>
            <button class="btn btn-success" onclick="startP2P()" id="p2pBtn">Start P2P Mode</button>
          </div>
          <small style="color: #666; display: block; margin-top: 5px;">
            <strong>WebSocket Server:</strong> One device acts as server, others connect to it.<br>
            <strong>P2P Mode:</strong> Direct device-to-device connections using WebRTC.
          </small>
        </div>

        <div class="form-group">
          <label>Local Network Devices</label>
          <div id="discoveredDevices">
            <p style="color: #666; padding: 20px; text-align: center;">Searching for devices on same WiFi...</p>
          </div>
        </div>

        <div class="form-group">
          <label>Connection Status</label>
          <div id="connectionStatus" style="padding: 15px; background: #f8f9fa; border-radius: 6px;">
            <p>Not connected</p>
            <p style="font-size: 12px; color: #666; margin-top: 5px;">Local IP: <span id="localIp">Detecting...</span></p>
          </div>
        </div>

        <div class="form-group">
          <label>Sync Log</label>
          <div id="syncLog" style="height: 200px; overflow-y: auto; padding: 10px; background: #f8f9fa; border-radius: 6px; font-family: monospace; font-size: 12px;">
          </div>
        </div>

        <div class="btn-group">
          <button class="btn btn-success" onclick="broadcastData()">Broadcast Data</button>
          <button class="btn btn-secondary" onclick="requestFullSync()">Request Full Sync</button>
          <button class="btn btn-danger" onclick="stopAllConnections()">Stop All Connections</button>
        </div>
      </div>

      <!-- Staff Chat Section -->
      <div id="chat" class="section">
        <h2 style="margin-bottom: 20px;">Staff Chat</h2>
        
        <div class="form-group">
          <label>Connected Staff</label>
          <div id="staffList">
            <p style="color: #666; padding: 10px; text-align: center;">No staff connected</p>
          </div>
        </div>

        <div class="form-group">
          <label>Chat Messages</label>
          <div id="chatMessages" style="height: 300px; overflow-y: auto; padding: 15px; background: #f8f9fa; border-radius: 6px; margin-bottom: 10px;">
            <p style="color: #666; text-align: center;">No messages yet</p>
          </div>
          
          <div class="chat-input">
            <input type="text" id="chatInput" placeholder="Type a message..." onkeypress="handleChatKeyPress(event)">
            <button class="btn btn-primary" onclick="sendChatMessage()">Send</button>
          </div>
        </div>

        <div class="form-group">
          <label>Quick Messages</label>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="btn btn-secondary" onclick="sendQuickMessage('Table ready for cleaning')">Table Clean</button>
            <button class="btn btn-secondary" onclick="sendQuickMessage('Order delayed')">Order Delay</button>
            <button class="btn btn-secondary" onclick="sendQuickMessage('Need assistance')">Assistance</button>
            <button class="btn btn-secondary" onclick="sendQuickMessage('Order ready')">Order Ready</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Add/Edit Table Modal -->
  <div id="tableModal" class="modal">
    <div class="modal-content">
      <h2 id="tableModalTitle">Add Table</h2>
      <div class="form-group">
        <label>Table Number</label>
        <input type="text" id="tableNumber" placeholder="e.g., T1, Table 1">
      </div>
      <div class="form-group">
        <label>Capacity</label>
        <input type="number" id="tableCapacity" placeholder="Number of seats">
      </div>
      <div class="btn-group">
        <button class="btn btn-primary" onclick="saveTable()">Save</button>
        <button class="btn btn-secondary" onclick="closeModal('tableModal')">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Add/Edit Menu Modal -->
  <div id="menuModal" class="modal">
    <div class="modal-content">
      <h2 id="menuModalTitle">Add Menu Item</h2>
      <div class="form-group">
        <label>Item Name</label>
        <input type="text" id="itemName" placeholder="e.g., Burger">
      </div>
      <div class="form-group">
        <label>Category</label>
        <input type="text" id="itemCategory" placeholder="e.g., Main Course">
      </div>
      <div class="form-group">
        <label>Price</label>
        <input type="number" id="itemPrice" step="0.01" placeholder="0.00">
      </div>
      <div class="form-group">
        <label>Description</label>
        <textarea id="itemDescription" rows="3" placeholder="Optional description"></textarea>
      </div>
      <div class="btn-group">
        <button class="btn btn-primary" onclick="saveMenuItem()">Save</button>
        <button class="btn btn-secondary" onclick="closeModal('menuModal')">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Order Modal -->
  <div id="orderModal" class="modal">
    <div class="modal-content">
      <h2 id="orderTableName">Table Order</h2>
      <div style="margin-bottom: 20px;">
        <h3>Menu</h3>
        <div id="orderMenuList"></div>
      </div>
      <div>
        <h3>Current Order</h3>
        <div id="currentOrderList"></div>
        <div class="order-summary">
          <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <span>Subtotal:</span>
            <span id="orderSubtotal">$0.00</span>
          </div>
          <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <span>Tax:</span>
            <span id="orderTax">$0.00</span>
          </div>
          <div style="display: flex; justify-content: space-between; font-size: 20px; font-weight: bold;">
            <span>Total:</span>
            <span id="orderTotal">$0.00</span>
          </div>
        </div>
      </div>
      <div class="btn-group">
        <button class="btn btn-success" onclick="placeOrder()">Place Order</button>
        <button class="btn btn-danger" onclick="checkout()">Checkout</button>
        <button class="btn btn-secondary" onclick="closeModal('orderModal')">Close</button>
      </div>
    </div>
  </div>

  <div class="sync-indicator" id="syncIndicator">
    <span class="sync-dot" id="syncDot"></span>
    <span id="syncText">Ready</span>
  </div>

  <script>
    // Initialize state
    let state = {
      tables: [],
      menu: [],
      orders: [],
      settings: { 
        restaurantName: 'My Restaurant', 
        taxRate: 8.5
      },
      currentTable: null,
      currentOrder: []
    };

    let editingId = null;
    let deviceId = localStorage.getItem('deviceId') || generateDeviceId();
    let deviceName = localStorage.getItem('deviceName') || 'POS Terminal ' + Math.floor(Math.random() * 100);
    let localIp = 'Unknown';
    let isServer = false;
    let wsServer = null;
    let wsClient = null;
    let peers = new Map();
    let connectedDevices = new Map();
    let chatMessages = [];
    let syncInterval = null;

    // Generate unique device ID
    function generateDeviceId() {
      const id = 'device_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('deviceId', id);
      return id;
    }

    // Initialize
    async function init() {
      // Load from localStorage
      loadFromLocalStorage();
      
      // Get local IP
      getLocalIP().then(ip => {
        localIp = ip;
        document.getElementById('localIp').textContent = ip;
        updateNetworkStatus('Connected to Local Network');
      });
      
      // Setup device
      document.getElementById('deviceName').value = deviceName;
      
      // Setup network discovery
      startNetworkDiscovery();
      
      // Start sync heartbeat
      syncInterval = setInterval(syncHeartbeat, 5000);
      
      // Initial render
      renderTables();
      renderMenu();
      renderKitchen();
      
      // Update UI
      updateConnectionStatus();
      updateSyncStatus('Ready');
    }

    // LocalStorage Functions
    function saveToLocalStorage() {
      try {
        localStorage.setItem('pos_state', JSON.stringify(state));
        console.log('Saved to localStorage');
        
        // Broadcast change to connected peers
        broadcastDataChange('local_update', { timestamp: Date.now() });
      } catch (e) {
        console.error('Error saving to localStorage:', e);
      }
    }

    function loadFromLocalStorage() {
      try {
        const saved = localStorage.getItem('pos_state');
        if (saved) {
          const parsed = JSON.parse(saved);
          state = { ...state, ...parsed };
          console.log('Loaded from localStorage');
        }
      } catch (e) {
        console.error('Error loading from localStorage:', e);
      }
    }

    // Network Functions
    async function getLocalIP() {
      return new Promise((resolve) => {
        // Try WebRTC to get local IP
        const RTCPeerConnection = window.RTCPeerConnection || 
                                 window.mozRTCPeerConnection || 
                                 window.webkitRTCPeerConnection;
        
        if (!RTCPeerConnection) {
          resolve('192.168.1.x'); // Fallback
          return;
        }

        const pc = new RTCPeerConnection({ iceServers: [] });
        pc.createDataChannel('');
        pc.createOffer().then(pc.setLocalDescription.bind(pc));
        
        pc.onicecandidate = (ice) => {
          if (!ice || !ice.candidate || !ice.candidate.candidate) return;
          const match = ice.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
          if (match) {
            resolve(match[1]);
            pc.close();
          }
        };
        
        // Timeout fallback
        setTimeout(() => {
          resolve('192.168.1.x');
          pc.close();
        }, 1000);
      });
    }

    function updateNetworkStatus(status) {
      const element = document.getElementById('networkStatus');
      element.textContent = status;
      
      if (status.includes('Local')) {
        element.className = 'network-status local';
      } else if (status.includes('Connected')) {
        element.className = 'network-status online';
      } else if (status.includes('Offline')) {
        element.className = 'network-status offline';
      }
    }

    // WebSocket Server (One device acts as server)
    function startWebSocketServer() {
      try {
        // Check if we can create a WebSocket server
        if (typeof WebSocket !== 'undefined') {
          // In browser, we can't create a WebSocket server directly
          // We'll use a signaling server approach
          alert('WebSocket Server requires Node.js. Switching to P2P mode instead.');
          startP2P();
          return;
        }
        
        // This would require Node.js - for demo we'll use P2P
        startP2P();
        
      } catch (error) {
        console.error('WebSocket server error:', error);
        addToSyncLog('Error starting server: ' + error.message);
      }
    }

    // WebSocket Client (Connect to server)
    function connectToWebSocket() {
      const serverIp = prompt('Enter server IP address (e.g., 192.168.1.100):', '192.168.1.100');
      if (!serverIp) return;
      
      const port = 8080; // Default port
      const wsUrl = `ws://${serverIp}:${port}`;
      
      try {
        wsClient = new WebSocket(wsUrl);
        
        wsClient.onopen = () => {
          addToSyncLog('Connected to WebSocket server');
          updateConnectionStatus('Connected to server');
          isServer = false;
          
          // Send device info
          wsClient.send(JSON.stringify({
            type: 'device_info',
            deviceId: deviceId,
            deviceName: deviceName,
            ip: localIp
          }));
        };
        
        wsClient.onmessage = (event) => {
          handleNetworkMessage(event.data);
        };
        
        wsClient.onerror = (error) => {
          addToSyncLog('WebSocket error: ' + error.message);
          updateConnectionStatus('Connection error');
        };
        
        wsClient.onclose = () => {
          addToSyncLog('Disconnected from server');
          updateConnectionStatus('Disconnected');
        };
        
      } catch (error) {
        alert('Failed to connect: ' + error.message);
        addToSyncLog('Connection failed: ' + error.message);
      }
    }

    // P2P WebRTC Connection
    function startP2P() {
      addToSyncLog('Starting P2P mode...');
      updateConnectionStatus('P2P Mode Active');
      
      // Start broadcasting presence
      broadcastPresence();
    }

    // Network Discovery
    function startNetworkDiscovery() {
      // Broadcast presence using WebSocket to common ports
      discoverLocalDevices();
      
      // Listen for broadcasts
      listenForBroadcasts();
    }

    function discoverLocalDevices() {
      // Try to connect to common ports on local network
      const ports = [8080, 8081, 8082, 3000, 3001];
      const baseIp = localIp.substring(0, localIp.lastIndexOf('.') + 1);
      
      addToSyncLog('Scanning network for devices...');
      
      // For each possible IP on subnet
      for (let i = 1; i < 255; i += 50) { // Sample every 50 IPs
        const testIp = baseIp + i;
        if (testIp !== localIp) {
          ports.forEach(port => {
            testConnection(testIp, port);
          });
        }
      }
    }

    function testConnection(ip, port) {
      // Create a temporary WebSocket to test connection
      const testWs = new WebSocket(`ws://${ip}:${port}`);
      
      testWs.onopen = () => {
        addToSyncLog(`Found device at ${ip}:${port}`);
        addDiscoveredDevice(ip, port, 'Connected');
        testWs.close();
      };
      
      testWs.onerror = () => {
        // Connection failed, ignore
        testWs.close();
      };
      
      // Timeout
      setTimeout(() => {
        if (testWs.readyState !== WebSocket.CLOSED) {
          testWs.close();
        }
      }, 1000);
    }

    function listenForBroadcasts() {
      // Listen on a specific port for broadcast messages
      // This is simplified - in real app, use WebRTC or WebSocket server
      addToSyncLog('Listening for device broadcasts...');
    }

    function broadcastPresence() {
      // Send UDP-like broadcast (simplified)
      addToSyncLog('Broadcasting presence to network...');
      
      // Store self as discovered device
      addDiscoveredDevice(localIp, 'Self', 'This Device');
      
      // Update discovered devices list
      updateDiscoveredDevices();
    }

    function addDiscoveredDevice(ip, port, status) {
      const deviceKey = `${ip}:${port}`;
      if (!connectedDevices.has(deviceKey)) {
        connectedDevices.set(deviceKey, {
          ip,
          port,
          status,
          lastSeen: Date.now()
        });
        updateDiscoveredDevices();
      } else {
        // Update last seen
        const device = connectedDevices.get(deviceKey);
        device.lastSeen = Date.now();
        device.status = status;
      }
    }

    function updateDiscoveredDevices() {
      const container = document.getElementById('discoveredDevices');
      const staffContainer = document.getElementById('staffList');
      
      if (connectedDevices.size === 0) {
        container.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No other devices found</p>';
        staffContainer.innerHTML = '<p style="color: #666; padding: 10px; text-align: center;">No staff connected</p>';
        return;
      }
      
      let devicesHTML = '';
      let staffHTML = '';
      
      connectedDevices.forEach((device, key) => {
        const isSelf = device.ip === localIp;
        const deviceClass = isSelf ? 'active' : '';
        const statusClass = device.status === 'Connected' ? 'connected' : '';
        
        devicesHTML += `
          <div class="device-card ${deviceClass}">
            <div class="device-info">
              <div class="device-name">${device.ip}:${device.port}</div>
              <div class="device-ip">Last seen: ${new Date(device.lastSeen).toLocaleTimeString()}</div>
            </div>
            <div class="device-status ${statusClass}">${device.status}</div>
          </div>
        `;
        
        if (!isSelf) {
          staffHTML += `
            <div class="device-card">
              <div class="device-info">
                <div class="device-name">Staff ${device.ip.split('.').pop()}</div>
                <div class="device-ip">${device.ip}</div>
              </div>
              <div class="device-status ${statusClass}">${device.status}</div>
            </div>
          `;
        }
      });
      
      container.innerHTML = devicesHTML;
      staffContainer.innerHTML = staffHTML || '<p style="color: #666; padding: 10px; text-align: center;">No staff connected</p>';
    }

    // Data Synchronization
    function broadcastData() {
      const dataToSend = {
        type: 'full_sync',
        deviceId: deviceId,
        deviceName: deviceName,
        data: state,
        timestamp: Date.now()
      };
      
      sendToAllPeers(dataToSend);
      addToSyncLog('Broadcasted data to all peers');
      updateSyncStatus('Data broadcasted', 'syncing');
      
      setTimeout(() => {
        updateSyncStatus('Ready', 'ready');
      }, 1000);
    }

    function requestFullSync() {
      const request = {
        type: 'request_sync',
        deviceId: deviceId,
        deviceName: deviceName,
        timestamp: Date.now()
      };
      
      sendToAllPeers(request);
      addToSyncLog('Requested sync from peers');
    }

    function syncHeartbeat() {
      // Send heartbeat to maintain connections
      const heartbeat = {
        type: 'heartbeat',
        deviceId: deviceId,
        deviceName: deviceName,
        timestamp: Date.now()
      };
      
      sendToAllPeers(heartbeat);
      
      // Clean up old devices
      const now = Date.now();
      connectedDevices.forEach((device, key) => {
        if (now - device.lastSeen > 30000) { // 30 seconds
          connectedDevices.delete(key);
        }
      });
      
      updateDiscoveredDevices();
    }

    function broadcastDataChange(changeType, data) {
      const change = {
        type: 'data_change',
        changeType: changeType,
        deviceId: deviceId,
        deviceName: deviceName,
        data: data,
        timestamp: Date.now()
      };
      
      sendToAllPeers(change);
    }

    // Network Message Handling
    function handleNetworkMessage(message) {
      try {
        const data = JSON.parse(message);
        
        switch (data.type) {
          case 'device_info':
            addDiscoveredDevice(data.ip, 'Unknown', 'Connected');
            addToSyncLog(`Device connected: ${data.deviceName}`);
            break;
            
          case 'full_sync':
            if (data.deviceId !== deviceId) {
              mergeData(data.data);
              addToSyncLog(`Received full sync from ${data.deviceName}`);
              updateSyncStatus('Synced from peer', 'synced');
            }
            break;
            
          case 'request_sync':
            // Send our data to requesting device
            broadcastData();
            addToSyncLog(`Sync requested by ${data.deviceName}`);
            break;
            
          case 'data_change':
            if (data.deviceId !== deviceId) {
              applyDataChange(data.changeType, data.data);
              addToSyncLog(`Update from ${data.deviceName}: ${data.changeType}`);
            }
            break;
            
          case 'heartbeat':
            addDiscoveredDevice(data.ip || 'Unknown', 'Unknown', 'Connected');
            break;
            
          case 'chat_message':
            if (data.deviceId !== deviceId) {
              receiveChatMessage(data);
            }
            break;
        }
        
      } catch (error) {
        console.error('Error handling network message:', error);
      }
    }

    function sendToAllPeers(data) {
      // Send via WebSocket if connected
      if (wsClient && wsClient.readyState === WebSocket.OPEN) {
        wsClient.send(JSON.stringify(data));
      }
      
      // Also broadcast via other methods
      broadcastToLocalNetwork(data);
    }

    function broadcastToLocalNetwork(data) {
      // Simplified broadcast - in real app, use WebRTC or WebSocket
      addToSyncLog('Broadcasting to local network...');
      
      // Simulate receiving our own broadcast for demo
      setTimeout(() => {
        if (Math.random() > 0.5) { // 50% chance to simulate response
          const simulatedResponse = {
            ...data,
            deviceId: 'simulated_device',
            deviceName: 'Simulated Device',
            ip: '192.168.1.' + Math.floor(Math.random() * 255)
          };
          handleNetworkMessage(JSON.stringify(simulatedResponse));
        }
      }, 500);
    }

    // Data Merging
    function mergeData(remoteData) {
      let changed = false;
      
      // Merge tables
      if (remoteData.tables) {
        remoteData.tables.forEach(remoteTable => {
          const localTable = state.tables.find(t => t.id === remoteTable.id);
          if (!localTable) {
            state.tables.push(remoteTable);
            changed = true;
          } else if (remoteTable.lastModified > (localTable.lastModified || 0)) {
            Object.assign(localTable, remoteTable);
            changed = true;
          }
        });
      }
      
      // Merge menu
      if (remoteData.menu) {
        remoteData.menu.forEach(remoteItem => {
          const localItem = state.menu.find(m => m.id === remoteItem.id);
          if (!localItem) {
            state.menu.push(remoteItem);
            changed = true;
          } else if (remoteItem.lastModified > (localItem.lastModified || 0)) {
            Object.assign(localItem, remoteItem);
            changed = true;
          }
        });
      }
      
      // Merge orders
      if (remoteData.orders) {
        remoteData.orders.forEach(remoteOrder => {
          const localOrder = state.orders.find(o => o.id === remoteOrder.id);
          if (!localOrder) {
            state.orders.push(remoteOrder);
            changed = true;
          } else if (remoteOrder.lastModified > (localOrder.lastModified || 0)) {
            Object.assign(localOrder, remoteOrder);
            changed = true;
          }
        });
      }
      
      if (changed) {
        saveToLocalStorage();
        renderTables();
        renderMenu();
        renderKitchen();
        addToSyncLog('Data merged successfully');
      }
    }

    function applyDataChange(changeType, data) {
      switch (changeType) {
        case 'table_update':
          renderTables();
          break;
        case 'menu_update':
          renderMenu();
          break;
        case 'order_update':
          renderKitchen();
          break;
        case 'new_order':
          // Play notification sound
          playNotificationSound();
          renderKitchen();
          break;
      }
    }

    // Chat Functions
    function sendChatMessage() {
      const input = document.getElementById('chatInput');
      const message = input.value.trim();
      
      if (!message) return;
      
      const chatData = {
        type: 'chat_message',
        deviceId: deviceId,
        deviceName: deviceName,
        message: message,
        timestamp: Date.now()
      };
      
      // Add to local chat
      addChatMessage(deviceName, message, true);
      
      // Send to peers
      sendToAllPeers(chatData);
      
      // Clear input
      input.value = '';
      input.focus();
    }

    function sendQuickMessage(message) {
      const chatData = {
        type: 'chat_message',
        deviceId: deviceId,
        deviceName: deviceName,
        message: message,
        timestamp: Date.now(),
        isQuick: true
      };
      
      addChatMessage(deviceName, message, true);
      sendToAllPeers(chatData);
      
      // Also play notification for urgent messages
      if (message.includes('assistance') || message.includes('delay')) {
        playNotificationSound();
      }
    }

    function receiveChatMessage(data) {
      addChatMessage(data.deviceName, data.message, false);
      
      // Play sound for new messages
      playNotificationSound();
    }

    function addChatMessage(sender, message, isLocal) {
      chatMessages.push({ sender, message, timestamp: Date.now(), isLocal });
      
      const container = document.getElementById('chatMessages');
      const messageClass = isLocal ? '' : 'remote';
      
      const messageHTML = `
        <div class="chat-message ${messageClass}">
          <strong>${sender}:</strong> ${message}
          <div style="font-size: 11px; color: #666; margin-top: 3px;">
            ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
          </div>
        </div>
      `;
      
      // Add to container
      if (container.children.length === 1 && container.children[0].textContent.includes('No messages')) {
        container.innerHTML = messageHTML;
      } else {
        container.innerHTML += messageHTML;
      }
      
      // Scroll to bottom
      container.scrollTop = container.scrollHeight;
    }

    function handleChatKeyPress(event) {
      if (event.key === 'Enter') {
        sendChatMessage();
      }
    }

    // UI Functions
    function updateDeviceName() {
      const newName = document.getElementById('deviceName').value.trim();
      if (newName) {
        deviceName = newName;
        localStorage.setItem('deviceName', newName);
        addToSyncLog('Device name updated to: ' + newName);
      }
    }

    function updateConnectionStatus() {
      const statusElement = document.getElementById('connectionStatus');
      let status = '';
      
      if (isServer) {
        status = `<strong>Status:</strong> Running as Server<br>`;
      } else if (wsClient && wsClient.readyState === WebSocket.OPEN) {
        status = `<strong>Status:</strong> Connected to Server<br>`;
      } else {
        status = `<strong>Status:</strong> P2P Mode<br>`;
      }
      
      status += `<strong>Device:</strong> ${deviceName}<br>`;
      status += `<strong>ID:</strong> ${deviceId.substring(0, 8)}...<br>`;
      status += `<strong>Connected Devices:</strong> ${connectedDevices.size - 1}`;
      
      statusElement.innerHTML = status;
    }

    function updateSyncStatus(message, status = 'ready') {
      const indicator = document.getElementById('syncIndicator');
      const dot = document.getElementById('syncDot');
      const text = document.getElementById('syncText');
      
      text.textContent = message;
      
      indicator.className = 'sync-indicator';
      dot.className = 'sync-dot';
      
      if (status === 'syncing') {
        indicator.classList.add('syncing');
        dot.classList.add('pulsing');
      } else if (status === 'error') {
        indicator.classList.add('error');
      }
    }

    function addToSyncLog(message) {
      const log = document.getElementById('syncLog');
      const entry = `[${new Date().toLocaleTimeString()}] ${message}\n`;
      
      // Add to log
      log.textContent += entry;
      
      // Scroll to bottom
      log.scrollTop = log.scrollHeight;
      
      // Keep log manageable
      const lines = log.textContent.split('\n');
      if (lines.length > 50) {
        log.textContent = lines.slice(-50).join('\n');
      }
    }

    function stopAllConnections() {
      if (wsClient) {
        wsClient.close();
        wsClient = null;
      }
      
      connectedDevices.clear();
      updateDiscoveredDevices();
      updateConnectionStatus();
      addToSyncLog('All connections stopped');
    }

    function playNotificationSound() {
      // Create a simple notification sound
      try {
        const context = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = context.createOscillator();
        const gainNode = context.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(context.destination);
        
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.5);
        
        oscillator.start(context.currentTime);
        oscillator.stop(context.currentTime + 0.5);
      } catch (e) {
        console.log('Audio not supported');
      }
    }

    // Navigation
    function showSection(section) {
      document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
      document.querySelectorAll('.nav button').forEach(b => b.classList.remove('active'));
      document.getElementById(section).classList.add('active');
      document.getElementById(`nav-${section}`).classList.add('active');
    }

    // Tables
    function renderTables() {
      const grid = document.getElementById('tablesGrid');
      grid.innerHTML = state.tables.map(t => `
        <div class="card ${t.occupied ? 'occupied' : ''}" onclick="openTable('${t.id}')">
          <h3>${t.number}</h3>
          <p>Capacity: ${t.capacity}</p>
          <p>${t.occupied ? 'Occupied' : 'Available'}</p>
          <button class="btn btn-secondary" style="margin-top: 10px; padding: 8px 16px;" onclick="event.stopPropagation(); editTable('${t.id}')">Edit</button>
        </div>
      `).join('');
    }

    function showAddTableModal() {
      editingId = null;
      document.getElementById('tableModalTitle').textContent = 'Add Table';
      document.getElementById('tableNumber').value = '';
      document.getElementById('tableCapacity').value = '';
      document.getElementById('tableModal').classList.add('active');
    }

    function editTable(id) {
      const table = state.tables.find(t => t.id === id);
      if (!table) return;
      
      editingId = id;
      document.getElementById('tableModalTitle').textContent = 'Edit Table';
      document.getElementById('tableNumber').value = table.number;
      document.getElementById('tableCapacity').value = table.capacity;
      document.getElementById('tableModal').classList.add('active');
    }

    function saveTable() {
      const number = document.getElementById('tableNumber').value.trim();
      const capacity = parseInt(document.getElementById('tableCapacity').value);
      
      if (!number || !capacity) {
        alert('Please fill all fields');
        return;
      }

      if (editingId) {
        const table = state.tables.find(t => t.id === editingId);
        table.number = number;
        table.capacity = capacity;
        table.lastModified = Date.now();
      } else {
        state.tables.push({
          id: Date.now().toString(),
          number,
          capacity,
          occupied: false,
          lastModified: Date.now()
        });
      }

      saveToLocalStorage();
      broadcastDataChange('table_update', { tableId: editingId || state.tables[state.tables.length-1].id });
      renderTables();
      closeModal('tableModal');
    }

    // Menu
    function renderMenu() {
      const list = document.getElementById('menuList');
      list.innerHTML = state.menu.map(item => `
        <div class="menu-item">
          <div class="menu-item-info">
            <h4>${item.name}</h4>
            <p style="color: #666;">${item.category}</p>
            <p style="font-size: 14px;">${item.description || ''}</p>
          </div>
          <div style="display: flex; align-items: center; gap: 15px;">
            <span class="menu-item-price">$${item.price.toFixed(2)}</span>
            <button class="btn btn-secondary" style="padding: 8px 16px;" onclick="editMenuItem('${item.id}')">Edit</button>
          </div>
        </div>
      `).join('');
    }

    function showAddMenuModal() {
      editingId = null;
      document.getElementById('menuModalTitle').textContent = 'Add Menu Item';
      document.getElementById('itemName').value = '';
      document.getElementById('itemCategory').value = '';
      document.getElementById('itemPrice').value = '';
      document.getElementById('itemDescription').value = '';
      document.getElementById('menuModal').classList.add('active');
    }

    function editMenuItem(id) {
      const item = state.menu.find(m => m.id === id);
      if (!item) return;
      
      editingId = id;
      document.getElementById('menuModalTitle').textContent = 'Edit Menu Item';
      document.getElementById('itemName').value = item.name;
      document.getElementById('itemCategory').value = item.category;
      document.getElementById('itemPrice').value = item.price;
      document.getElementById('itemDescription').value = item.description || '';
      document.getElementById('menuModal').classList.add('active');
    }

    function saveMenuItem() {
      const name = document.getElementById('itemName').value.trim();
      const category = document.getElementById('itemCategory').value.trim();
      const price = parseFloat(document.getElementById('itemPrice').value);
      const description = document.getElementById('itemDescription').value.trim();
      
      if (!name || !category || !price) {
        alert('Please fill required fields');
        return;
      }

      if (editingId) {
        const item = state.menu.find(m => m.id === editingId);
        item.name = name;
        item.category = category;
        item.price = price;
        item.description = description;
        item.lastModified = Date.now();
      } else {
        state.menu.push({
          id: Date.now().toString(),
          name,
          category,
          price,
          description,
          lastModified: Date.now()
        });
      }

      saveToLocalStorage();
      broadcastDataChange('menu_update', { itemId: editingId || state.menu[state.menu.length-1].id });
      renderMenu();
      closeModal('menuModal');
    }

    // Orders
    function openTable(tableId) {
      const table = state.tables.find(t => t.id === tableId);
      if (!table) return;

      state.currentTable = tableId;
      const existingOrder = state.orders.find(o => o.tableId === tableId && o.status !== 'completed');
      state.currentOrder = existingOrder ? existingOrder.items : [];

      document.getElementById('orderTableName').textContent = `Table ${table.number}`;
      
      const menuList = document.getElementById('orderMenuList');
      menuList.innerHTML = state.menu.map(item => `
        <div class="menu-item">
          <div class="menu-item-info">
            <h4>${item.name}</h4>
            <span class="menu-item-price">$${item.price.toFixed(2)}</span>
          </div>
          <button class="btn btn-primary" style="padding: 8px 16px;" onclick="addToOrder('${item.id}')">Add</button>
        </div>
      `).join('');

      updateOrderDisplay();
      document.getElementById('orderModal').classList.add('active');
    }

    function addToOrder(itemId) {
      const item = state.menu.find(m => m.id === itemId);
      if (!item) return;

      const existing = state.currentOrder.find(o => o.id === itemId);
      if (existing) {
        existing.quantity++;
      } else {
        state.currentOrder.push({ ...item, quantity: 1 });
      }

      updateOrderDisplay();
    }

    function removeFromOrder(itemId) {
      state.currentOrder = state.currentOrder.filter(i => i.id !== itemId);
      updateOrderDisplay();
    }

    function updateOrderDisplay() {
      const list = document.getElementById('currentOrderList');
      
      if (state.currentOrder.length === 0) {
        list.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No items added</p>';
      } else {
        list.innerHTML = state.currentOrder.map(item => `
          <div class="order-item">
            <div>
              <strong>${item.name}</strong>
              <span style="margin-left: 10px;">x${item.quantity}</span>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
              <span>$${(item.price * item.quantity).toFixed(2)}</span>
              <button class="btn btn-danger" style="padding: 5px 10px; font-size: 14px;" onclick="removeFromOrder('${item.id}')">Remove</button>
            </div>
          </div>
        `).join('');
      }

      const subtotal = state.currentOrder.reduce((sum, item) => sum + (item.price * item.quantity), 0);
      const tax = subtotal * (state.settings.taxRate / 100);
      const total = subtotal + tax;

      document.getElementById('orderSubtotal').textContent = `$${subtotal.toFixed(2)}`;
      document.getElementById('orderTax').textContent = `$${tax.toFixed(2)}`;
      document.getElementById('orderTotal').textContent = `$${total.toFixed(2)}`;
    }

    function placeOrder() {
      if (state.currentOrder.length === 0) {
        alert('Add items to order');
        return;
      }

      const table = state.tables.find(t => t.id === state.currentTable);
      table.occupied = true;

      const existingOrder = state.orders.find(o => o.tableId === state.currentTable && o.status !== 'completed');
      
      if (existingOrder) {
        existingOrder.items = state.currentOrder;
        existingOrder.updatedAt = new Date().toISOString();
        existingOrder.lastModified = Date.now();
      } else {
        state.orders.push({
          id: Date.now().toString(),
          tableId: state.currentTable,
          tableName: table.number,
          items: state.currentOrder,
          status: 'new',
          createdAt: new Date().toISOString(),
          lastModified: Date.now()
        });
      }

      saveToLocalStorage();
      broadcastDataChange('new_order', { 
        orderId: state.orders[state.orders.length-1].id,
        tableName: table.number 
      });
      renderTables();
      alert('Order placed!');
      closeModal('orderModal');
    }

    function checkout() {
      if (state.currentOrder.length === 0) {
        alert('No items to checkout');
        return;
      }

      const table = state.tables.find(t => t.id === state.currentTable);
      table.occupied = false;

      const order = state.orders.find(o => o.tableId === state.currentTable && o.status !== 'completed');
      if (order) {
        order.status = 'completed';
        order.lastModified = Date.now();
      }

      saveToLocalStorage();
      broadcastDataChange('checkout', { tableId: state.currentTable });
      renderTables();
      alert('Checkout complete!');
      closeModal('orderModal');
    }

    // Kitchen
    function renderKitchen() {
      const container = document.getElementById('kitchenOrders');
      const activeOrders = state.orders.filter(o => o.status !== 'completed');

      if (activeOrders.length === 0) {
        container.innerHTML = '<p style="color: #666; text-align: center; padding: 40px;">No active orders</p>';
        return;
      }

      container.innerHTML = activeOrders.map(order => `
        <div class="order-card ${order.status}">
          <div class="order-header">
            <div>
              <h3>Table ${order.tableName}</h3>
              <p style="color: #666; font-size: 14px;">${new Date(order.createdAt).toLocaleTimeString()}</p>
            </div>
            <span class="status-badge ${order.status}">${order.status.toUpperCase()}</span>
          </div>
          <div>
            ${order.items.map(item => `
              <div style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;">
                <strong>${item.name}</strong> x${item.quantity}
              </div>
            `).join('')}
          </div>
          <div class="btn-group">
            <button class="btn btn-primary" style="padding: 8px 16px;" onclick="updateOrderStatus('${order.id}', 'processing')">Processing</button>
            <button class="btn btn-success" style="padding: 8px 16px;" onclick="updateOrderStatus('${order.id}', 'ready')">Ready</button>
          </div>
        </div>
      `).join('');
    }

    function updateOrderStatus(orderId, status) {
      const order = state.orders.find(o => o.id === orderId);
      if (order) {
        order.status = status;
        order.lastModified = Date.now();
        saveToLocalStorage();
        broadcastDataChange('order_status', { orderId, status });
        renderKitchen();
      }
    }

    // Modal
    function closeModal(id) {
      document.getElementById(id).classList.remove('active');
    }

    // Start app
    init();
  </script>
</body>
</html>
